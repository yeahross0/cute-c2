#![allow(non_upper_case_globals)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]

/* automatically generated by rust-bindgen */

pub const C2_MAX_POLYGON_VERTS: u32 = 8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct c2v {
    pub x: f32,
    pub y: f32,
}
#[test]
fn bindgen_test_layout_c2v() {
    assert_eq!(
        ::std::mem::size_of::<c2v>(),
        8usize,
        concat!("Size of: ", stringify!(c2v))
    );
    assert_eq!(
        ::std::mem::align_of::<c2v>(),
        4usize,
        concat!("Alignment of ", stringify!(c2v))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<c2v>())).x as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(c2v), "::", stringify!(x))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<c2v>())).y as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(c2v), "::", stringify!(y))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct c2r {
    pub c: f32,
    pub s: f32,
}
#[test]
fn bindgen_test_layout_c2r() {
    assert_eq!(
        ::std::mem::size_of::<c2r>(),
        8usize,
        concat!("Size of: ", stringify!(c2r))
    );
    assert_eq!(
        ::std::mem::align_of::<c2r>(),
        4usize,
        concat!("Alignment of ", stringify!(c2r))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<c2r>())).c as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(c2r), "::", stringify!(c))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<c2r>())).s as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(c2r), "::", stringify!(s))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct c2m {
    pub x: c2v,
    pub y: c2v,
}
#[test]
fn bindgen_test_layout_c2m() {
    assert_eq!(
        ::std::mem::size_of::<c2m>(),
        16usize,
        concat!("Size of: ", stringify!(c2m))
    );
    assert_eq!(
        ::std::mem::align_of::<c2m>(),
        4usize,
        concat!("Alignment of ", stringify!(c2m))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<c2m>())).x as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(c2m), "::", stringify!(x))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<c2m>())).y as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(c2m), "::", stringify!(y))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct c2x {
    pub p: c2v,
    pub r: c2r,
}
#[test]
fn bindgen_test_layout_c2x() {
    assert_eq!(
        ::std::mem::size_of::<c2x>(),
        16usize,
        concat!("Size of: ", stringify!(c2x))
    );
    assert_eq!(
        ::std::mem::align_of::<c2x>(),
        4usize,
        concat!("Alignment of ", stringify!(c2x))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<c2x>())).p as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(c2x), "::", stringify!(p))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<c2x>())).r as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(c2x), "::", stringify!(r))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct c2h {
    pub n: c2v,
    pub d: f32,
}
#[test]
fn bindgen_test_layout_c2h() {
    assert_eq!(
        ::std::mem::size_of::<c2h>(),
        12usize,
        concat!("Size of: ", stringify!(c2h))
    );
    assert_eq!(
        ::std::mem::align_of::<c2h>(),
        4usize,
        concat!("Alignment of ", stringify!(c2h))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<c2h>())).n as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(c2h), "::", stringify!(n))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<c2h>())).d as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(c2h), "::", stringify!(d))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct c2Circle {
    pub p: c2v,
    pub r: f32,
}
#[test]
fn bindgen_test_layout_c2Circle() {
    assert_eq!(
        ::std::mem::size_of::<c2Circle>(),
        12usize,
        concat!("Size of: ", stringify!(c2Circle))
    );
    assert_eq!(
        ::std::mem::align_of::<c2Circle>(),
        4usize,
        concat!("Alignment of ", stringify!(c2Circle))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<c2Circle>())).p as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(c2Circle),
            "::",
            stringify!(p)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<c2Circle>())).r as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(c2Circle),
            "::",
            stringify!(r)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct c2AABB {
    pub min: c2v,
    pub max: c2v,
}
#[test]
fn bindgen_test_layout_c2AABB() {
    assert_eq!(
        ::std::mem::size_of::<c2AABB>(),
        16usize,
        concat!("Size of: ", stringify!(c2AABB))
    );
    assert_eq!(
        ::std::mem::align_of::<c2AABB>(),
        4usize,
        concat!("Alignment of ", stringify!(c2AABB))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<c2AABB>())).min as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(c2AABB),
            "::",
            stringify!(min)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<c2AABB>())).max as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(c2AABB),
            "::",
            stringify!(max)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct c2Capsule {
    pub a: c2v,
    pub b: c2v,
    pub r: f32,
}
#[test]
fn bindgen_test_layout_c2Capsule() {
    assert_eq!(
        ::std::mem::size_of::<c2Capsule>(),
        20usize,
        concat!("Size of: ", stringify!(c2Capsule))
    );
    assert_eq!(
        ::std::mem::align_of::<c2Capsule>(),
        4usize,
        concat!("Alignment of ", stringify!(c2Capsule))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<c2Capsule>())).a as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(c2Capsule),
            "::",
            stringify!(a)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<c2Capsule>())).b as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(c2Capsule),
            "::",
            stringify!(b)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<c2Capsule>())).r as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(c2Capsule),
            "::",
            stringify!(r)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct c2Poly {
    pub count: ::std::os::raw::c_int,
    pub verts: [c2v; 8usize],
    pub norms: [c2v; 8usize],
}
#[test]
fn bindgen_test_layout_c2Poly() {
    assert_eq!(
        ::std::mem::size_of::<c2Poly>(),
        132usize,
        concat!("Size of: ", stringify!(c2Poly))
    );
    assert_eq!(
        ::std::mem::align_of::<c2Poly>(),
        4usize,
        concat!("Alignment of ", stringify!(c2Poly))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<c2Poly>())).count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(c2Poly),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<c2Poly>())).verts as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(c2Poly),
            "::",
            stringify!(verts)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<c2Poly>())).norms as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(c2Poly),
            "::",
            stringify!(norms)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct c2Ray {
    pub p: c2v,
    pub d: c2v,
    pub t: f32,
}
#[test]
fn bindgen_test_layout_c2Ray() {
    assert_eq!(
        ::std::mem::size_of::<c2Ray>(),
        20usize,
        concat!("Size of: ", stringify!(c2Ray))
    );
    assert_eq!(
        ::std::mem::align_of::<c2Ray>(),
        4usize,
        concat!("Alignment of ", stringify!(c2Ray))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<c2Ray>())).p as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(c2Ray), "::", stringify!(p))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<c2Ray>())).d as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(c2Ray), "::", stringify!(d))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<c2Ray>())).t as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(c2Ray), "::", stringify!(t))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct c2Raycast {
    pub t: f32,
    pub n: c2v,
}
#[test]
fn bindgen_test_layout_c2Raycast() {
    assert_eq!(
        ::std::mem::size_of::<c2Raycast>(),
        12usize,
        concat!("Size of: ", stringify!(c2Raycast))
    );
    assert_eq!(
        ::std::mem::align_of::<c2Raycast>(),
        4usize,
        concat!("Alignment of ", stringify!(c2Raycast))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<c2Raycast>())).t as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(c2Raycast),
            "::",
            stringify!(t)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<c2Raycast>())).n as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(c2Raycast),
            "::",
            stringify!(n)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct c2Manifold {
    pub count: ::std::os::raw::c_int,
    pub depths: [f32; 2usize],
    pub contact_points: [c2v; 2usize],
    pub n: c2v,
}
#[test]
fn bindgen_test_layout_c2Manifold() {
    assert_eq!(
        ::std::mem::size_of::<c2Manifold>(),
        36usize,
        concat!("Size of: ", stringify!(c2Manifold))
    );
    assert_eq!(
        ::std::mem::align_of::<c2Manifold>(),
        4usize,
        concat!("Alignment of ", stringify!(c2Manifold))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<c2Manifold>())).count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(c2Manifold),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<c2Manifold>())).depths as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(c2Manifold),
            "::",
            stringify!(depths)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<c2Manifold>())).contact_points as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(c2Manifold),
            "::",
            stringify!(contact_points)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<c2Manifold>())).n as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(c2Manifold),
            "::",
            stringify!(n)
        )
    );
}
extern "C" {
    pub fn c2CircletoCircle(A: c2Circle, B: c2Circle) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn c2CircletoAABB(A: c2Circle, B: c2AABB) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn c2CircletoCapsule(A: c2Circle, B: c2Capsule) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn c2AABBtoAABB(A: c2AABB, B: c2AABB) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn c2AABBtoCapsule(A: c2AABB, B: c2Capsule) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn c2CapsuletoCapsule(A: c2Capsule, B: c2Capsule) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn c2CircletoPoly(A: c2Circle, B: *const c2Poly, bx: *const c2x) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn c2AABBtoPoly(A: c2AABB, B: *const c2Poly, bx: *const c2x) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn c2CapsuletoPoly(A: c2Capsule, B: *const c2Poly, bx: *const c2x)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn c2PolytoPoly(
        A: *const c2Poly,
        ax: *const c2x,
        B: *const c2Poly,
        bx: *const c2x,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn c2RaytoCircle(A: c2Ray, B: c2Circle, out: *mut c2Raycast) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn c2RaytoAABB(A: c2Ray, B: c2AABB, out: *mut c2Raycast) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn c2RaytoCapsule(A: c2Ray, B: c2Capsule, out: *mut c2Raycast) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn c2RaytoPoly(
        A: c2Ray,
        B: *const c2Poly,
        bx_ptr: *const c2x,
        out: *mut c2Raycast,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn c2CircletoCircleManifold(A: c2Circle, B: c2Circle, m: *mut c2Manifold);
}
extern "C" {
    pub fn c2CircletoAABBManifold(A: c2Circle, B: c2AABB, m: *mut c2Manifold);
}
extern "C" {
    pub fn c2CircletoCapsuleManifold(A: c2Circle, B: c2Capsule, m: *mut c2Manifold);
}
extern "C" {
    pub fn c2AABBtoAABBManifold(A: c2AABB, B: c2AABB, m: *mut c2Manifold);
}
extern "C" {
    pub fn c2AABBtoCapsuleManifold(A: c2AABB, B: c2Capsule, m: *mut c2Manifold);
}
extern "C" {
    pub fn c2CapsuletoCapsuleManifold(A: c2Capsule, B: c2Capsule, m: *mut c2Manifold);
}
extern "C" {
    pub fn c2CircletoPolyManifold(
        A: c2Circle,
        B: *const c2Poly,
        bx: *const c2x,
        m: *mut c2Manifold,
    );
}
extern "C" {
    pub fn c2AABBtoPolyManifold(A: c2AABB, B: *const c2Poly, bx: *const c2x, m: *mut c2Manifold);
}
extern "C" {
    pub fn c2CapsuletoPolyManifold(
        A: c2Capsule,
        B: *const c2Poly,
        bx: *const c2x,
        m: *mut c2Manifold,
    );
}
extern "C" {
    pub fn c2PolytoPolyManifold(
        A: *const c2Poly,
        ax: *const c2x,
        B: *const c2Poly,
        bx: *const c2x,
        m: *mut c2Manifold,
    );
}
pub const C2_TYPE_C2_TYPE_NONE: C2_TYPE = 0;
pub const C2_TYPE_C2_TYPE_CIRCLE: C2_TYPE = 1;
pub const C2_TYPE_C2_TYPE_AABB: C2_TYPE = 2;
pub const C2_TYPE_C2_TYPE_CAPSULE: C2_TYPE = 3;
pub const C2_TYPE_C2_TYPE_POLY: C2_TYPE = 4;
pub type C2_TYPE = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct c2GJKCache {
    pub metric: f32,
    pub count: ::std::os::raw::c_int,
    pub iA: [::std::os::raw::c_int; 3usize],
    pub iB: [::std::os::raw::c_int; 3usize],
    pub div: f32,
}
#[test]
fn bindgen_test_layout_c2GJKCache() {
    assert_eq!(
        ::std::mem::size_of::<c2GJKCache>(),
        36usize,
        concat!("Size of: ", stringify!(c2GJKCache))
    );
    assert_eq!(
        ::std::mem::align_of::<c2GJKCache>(),
        4usize,
        concat!("Alignment of ", stringify!(c2GJKCache))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<c2GJKCache>())).metric as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(c2GJKCache),
            "::",
            stringify!(metric)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<c2GJKCache>())).count as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(c2GJKCache),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<c2GJKCache>())).iA as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(c2GJKCache),
            "::",
            stringify!(iA)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<c2GJKCache>())).iB as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(c2GJKCache),
            "::",
            stringify!(iB)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<c2GJKCache>())).div as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(c2GJKCache),
            "::",
            stringify!(div)
        )
    );
}
extern "C" {
    pub fn c2GJK(
        A: *const ::std::os::raw::c_void,
        typeA: C2_TYPE,
        ax_ptr: *const c2x,
        B: *const ::std::os::raw::c_void,
        typeB: C2_TYPE,
        bx_ptr: *const c2x,
        outA: *mut c2v,
        outB: *mut c2v,
        use_radius: ::std::os::raw::c_int,
        iterations: *mut ::std::os::raw::c_int,
        cache: *mut c2GJKCache,
    ) -> f32;
}
extern "C" {
    pub fn c2TOI(
        A: *const ::std::os::raw::c_void,
        typeA: C2_TYPE,
        ax_ptr: *const c2x,
        vA: c2v,
        B: *const ::std::os::raw::c_void,
        typeB: C2_TYPE,
        bx_ptr: *const c2x,
        vB: c2v,
        use_radius: ::std::os::raw::c_int,
        iterations: *mut ::std::os::raw::c_int,
    ) -> f32;
}
extern "C" {
    pub fn c2Hull(verts: *mut c2v, count: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn c2Norms(verts: *mut c2v, norms: *mut c2v, count: ::std::os::raw::c_int);
}
extern "C" {
    pub fn c2MakePoly(p: *mut c2Poly);
}
extern "C" {
    pub fn c2Collided(
        A: *const ::std::os::raw::c_void,
        ax: *const c2x,
        typeA: C2_TYPE,
        B: *const ::std::os::raw::c_void,
        bx: *const c2x,
        typeB: C2_TYPE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn c2Collide(
        A: *const ::std::os::raw::c_void,
        ax: *const c2x,
        typeA: C2_TYPE,
        B: *const ::std::os::raw::c_void,
        bx: *const c2x,
        typeB: C2_TYPE,
        m: *mut c2Manifold,
    );
}
extern "C" {
    pub fn c2CastRay(
        A: c2Ray,
        B: *const ::std::os::raw::c_void,
        bx: *const c2x,
        typeB: C2_TYPE,
        out: *mut c2Raycast,
    ) -> ::std::os::raw::c_int;
}
